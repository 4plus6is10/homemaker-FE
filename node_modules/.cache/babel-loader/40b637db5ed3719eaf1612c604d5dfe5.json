{"ast":null,"code":"/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule moveBlockInContentState\r\n * @format\r\n * \r\n */\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\n\nvar Immutable = require('immutable');\n\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar OrderedMap = Immutable.OrderedMap,\n    List = Immutable.List;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  } // possible values of 'insertionMode' are: 'after', 'before'\n\n\n  var isInsertedAfterTarget = insertionMode === 'after';\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))\n      });\n    }); // update old prev\n\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    }); // update old next\n\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    }); // update new next\n\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    }); // update new prev\n\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    }); // update new parent\n\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    }); // update block\n\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\n\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);\n\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks['delete'](block.getKey());\n      });\n    });\n  }\n\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n  var newBlocks = OrderedMap();\n\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\n\nmodule.exports = moveBlockInContentState;","map":{"version":3,"names":["ContentBlockNode","require","Immutable","getNextDelimiterBlockKey","invariant","OrderedMap","List","transformBlock","key","blockMap","func","block","get","set","updateBlockMapLinks","originalBlockToBeMoved","originalTargetBlock","insertionMode","isExperimentalTreeBlock","isInsertedAfterTarget","originalBlockKey","getKey","originalTargetKey","originalParentKey","getParentKey","originalNextSiblingKey","getNextSiblingKey","originalPrevSiblingKey","getPrevSiblingKey","newParentKey","newNextSiblingKey","newPrevSiblingKey","withMutations","blocks","parentChildrenList","getChildKeys","merge","children","indexOf","nextSibling","prevSibling","newParentChildrenList","targetBlockIndex","insertionIndex","newChildrenArray","toArray","splice","parent","moveBlockInContentState","contentState","blockToBeMoved","targetBlock","process","env","NODE_ENV","targetKey","blockKey","getBlockMap","blocksToBeMoved","blockMapWithoutBlocksToBeMoved","nextSiblingKey","nextDelimiterBlockKey","toSeq","skipUntil","takeWhile","isBlockToBeMoved","hasNextSiblingAndIsNotNextSibling","doesNotHaveNextSiblingAndIsNotDelimiter","forEach","push","blocksBefore","takeUntil","v","blocksAfter","skip","slicedBlocks","map","newBlocks","blockBefore","getBlockBefore","concat","toOrderedMap","blockAfter","getBlockAfter","selectionBefore","getSelectionAfter","selectionAfter","anchorKey","focusKey","module","exports"],"sources":["C:/20220103_lab/15.final_project/Front/homemaker-FE/node_modules/draft-js/lib/moveBlockInContentState.js"],"sourcesContent":["/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule moveBlockInContentState\r\n * @format\r\n * \r\n */\r\n\r\n'use strict';\r\n\r\nvar ContentBlockNode = require('./ContentBlockNode');\r\nvar Immutable = require('immutable');\r\n\r\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\r\nvar invariant = require('fbjs/lib/invariant');\r\n\r\nvar OrderedMap = Immutable.OrderedMap,\r\n    List = Immutable.List;\r\n\r\n\r\nvar transformBlock = function transformBlock(key, blockMap, func) {\r\n  if (!key) {\r\n    return;\r\n  }\r\n\r\n  var block = blockMap.get(key);\r\n\r\n  if (!block) {\r\n    return;\r\n  }\r\n\r\n  blockMap.set(key, func(block));\r\n};\r\n\r\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\r\n  if (!isExperimentalTreeBlock) {\r\n    return blockMap;\r\n  }\r\n  // possible values of 'insertionMode' are: 'after', 'before'\r\n  var isInsertedAfterTarget = insertionMode === 'after';\r\n\r\n  var originalBlockKey = originalBlockToBeMoved.getKey();\r\n  var originalTargetKey = originalTargetBlock.getKey();\r\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\r\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\r\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\r\n  var newParentKey = originalTargetBlock.getParentKey();\r\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\r\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\r\n\r\n  return blockMap.withMutations(function (blocks) {\r\n    // update old parent\r\n    transformBlock(originalParentKey, blocks, function (block) {\r\n      var parentChildrenList = block.getChildKeys();\r\n      return block.merge({\r\n        children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))\r\n      });\r\n    });\r\n\r\n    // update old prev\r\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\r\n      return block.merge({\r\n        nextSibling: originalNextSiblingKey\r\n      });\r\n    });\r\n\r\n    // update old next\r\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\r\n      return block.merge({\r\n        prevSibling: originalPrevSiblingKey\r\n      });\r\n    });\r\n\r\n    // update new next\r\n    transformBlock(newNextSiblingKey, blocks, function (block) {\r\n      return block.merge({\r\n        prevSibling: originalBlockKey\r\n      });\r\n    });\r\n\r\n    // update new prev\r\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\r\n      return block.merge({\r\n        nextSibling: originalBlockKey\r\n      });\r\n    });\r\n\r\n    // update new parent\r\n    transformBlock(newParentKey, blocks, function (block) {\r\n      var newParentChildrenList = block.getChildKeys();\r\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\r\n\r\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\r\n\r\n      var newChildrenArray = newParentChildrenList.toArray();\r\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\r\n\r\n      return block.merge({\r\n        children: List(newChildrenArray)\r\n      });\r\n    });\r\n\r\n    // update block\r\n    transformBlock(originalBlockKey, blocks, function (block) {\r\n      return block.merge({\r\n        nextSibling: newNextSiblingKey,\r\n        prevSibling: newPrevSiblingKey,\r\n        parent: newParentKey\r\n      });\r\n    });\r\n  });\r\n};\r\n\r\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\r\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\r\n\r\n  var targetKey = targetBlock.getKey();\r\n  var blockKey = blockToBeMoved.getKey();\r\n\r\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\r\n\r\n  var blockMap = contentState.getBlockMap();\r\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\r\n\r\n  var blocksToBeMoved = [blockToBeMoved];\r\n  var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);\r\n\r\n  if (isExperimentalTreeBlock) {\r\n    blocksToBeMoved = [];\r\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\r\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\r\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\r\n\r\n      blocks.toSeq().skipUntil(function (block) {\r\n        return block.getKey() === blockKey;\r\n      }).takeWhile(function (block) {\r\n        var key = block.getKey();\r\n        var isBlockToBeMoved = key === blockKey;\r\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\r\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\r\n\r\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\r\n      }).forEach(function (block) {\r\n        blocksToBeMoved.push(block);\r\n        blocks['delete'](block.getKey());\r\n      });\r\n    });\r\n  }\r\n\r\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\r\n    return v === targetBlock;\r\n  });\r\n\r\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\r\n    return v === targetBlock;\r\n  }).skip(1);\r\n\r\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\r\n    return [block.getKey(), block];\r\n  });\r\n\r\n  var newBlocks = OrderedMap();\r\n\r\n  if (insertionMode === 'before') {\r\n    var blockBefore = contentState.getBlockBefore(targetKey);\r\n\r\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\r\n\r\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\r\n  } else if (insertionMode === 'after') {\r\n    var blockAfter = contentState.getBlockAfter(targetKey);\r\n\r\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\r\n\r\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\r\n  }\r\n\r\n  return contentState.merge({\r\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\r\n    selectionBefore: contentState.getSelectionAfter(),\r\n    selectionAfter: contentState.getSelectionAfter().merge({\r\n      anchorKey: blockKey,\r\n      focusKey: blockKey\r\n    })\r\n  });\r\n};\r\n\r\nmodule.exports = moveBlockInContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script"}