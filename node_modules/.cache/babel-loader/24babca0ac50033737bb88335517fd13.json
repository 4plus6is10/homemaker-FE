{"ast":null,"code":"/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule getCharacterRemovalRange\r\n * @format\r\n * \r\n */\n'use strict';\n\nvar DraftEntitySegments = require('./DraftEntitySegments');\n\nvar getRangesForDraftEntity = require('./getRangesForDraftEntity');\n\nvar invariant = require('fbjs/lib/invariant');\n/**\r\n * Given a SelectionState and a removal direction, determine the entire range\r\n * that should be removed from a ContentState. This is based on any entities\r\n * within the target, with their `mutability` values taken into account.\r\n *\r\n * For instance, if we are attempting to remove part of an \"immutable\" entity\r\n * range, the entire entity must be removed. The returned `SelectionState`\r\n * will be adjusted accordingly.\r\n */\n\n\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var startEntityKey = startBlock.getEntityAt(start);\n  var endEntityKey = endBlock.getEntityAt(end - 1);\n\n  if (!startEntityKey && !endEntityKey) {\n    return selectionState;\n  }\n\n  var newSelectionState = selectionState;\n\n  if (startEntityKey && startEntityKey === endEntityKey) {\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\n  } else if (startEntityKey && endEntityKey) {\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: startSelectionState.getAnchorOffset(),\n      focusOffset: endSelectionState.getFocusOffset(),\n      isBackward: false\n    });\n  } else if (startEntityKey) {\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: _startSelectionState.getStartOffset(),\n      isBackward: false\n    });\n  } else if (endEntityKey) {\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n\n    newSelectionState = newSelectionState.merge({\n      focusOffset: _endSelectionState.getEndOffset(),\n      isBackward: false\n    });\n  }\n\n  return newSelectionState;\n}\n\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n\n  var entity = entityMap.__get(entityKey);\n\n  var mutability = entity.getMutability();\n  var sideToConsider = isEntityAtStart ? start : end; // `MUTABLE` entities can just have the specified range of text removed\n  // directly. No adjustments are needed.\n\n  if (mutability === 'MUTABLE') {\n    return selectionState;\n  } // Find the entity range that overlaps with our removal range.\n\n\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\n    return sideToConsider <= range.end && sideToConsider >= range.start;\n  });\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\n  var entityRange = entityRanges[0]; // For `IMMUTABLE` entity types, we will remove the entire entity range.\n\n  if (mutability === 'IMMUTABLE') {\n    return selectionState.merge({\n      anchorOffset: entityRange.start,\n      focusOffset: entityRange.end,\n      isBackward: false\n    });\n  } // For `SEGMENTED` entity types, determine the appropriate segment to\n  // remove.\n\n\n  if (!isEntireSelectionWithinEntity) {\n    if (isEntityAtStart) {\n      end = entityRange.end;\n    } else {\n      start = entityRange.start;\n    }\n  }\n\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\n  return selectionState.merge({\n    anchorOffset: removalRange.start,\n    focusOffset: removalRange.end,\n    isBackward: false\n  });\n}\n\nmodule.exports = getCharacterRemovalRange;","map":{"version":3,"names":["DraftEntitySegments","require","getRangesForDraftEntity","invariant","getCharacterRemovalRange","entityMap","startBlock","endBlock","selectionState","direction","start","getStartOffset","end","getEndOffset","startEntityKey","getEntityAt","endEntityKey","newSelectionState","getEntityRemovalRange","startSelectionState","endSelectionState","merge","anchorOffset","getAnchorOffset","focusOffset","getFocusOffset","isBackward","_startSelectionState","_endSelectionState","block","entityKey","isEntireSelectionWithinEntity","isEntityAtStart","entity","__get","mutability","getMutability","sideToConsider","entityRanges","filter","range","length","process","env","NODE_ENV","entityRange","removalRange","getRemovalRange","getText","slice","module","exports"],"sources":["C:/20220103_lab/15.final_project/Front/homemaker-FE/node_modules/draft-js/lib/getCharacterRemovalRange.js"],"sourcesContent":["/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule getCharacterRemovalRange\r\n * @format\r\n * \r\n */\r\n\r\n'use strict';\r\n\r\nvar DraftEntitySegments = require('./DraftEntitySegments');\r\n\r\nvar getRangesForDraftEntity = require('./getRangesForDraftEntity');\r\nvar invariant = require('fbjs/lib/invariant');\r\n\r\n/**\r\n * Given a SelectionState and a removal direction, determine the entire range\r\n * that should be removed from a ContentState. This is based on any entities\r\n * within the target, with their `mutability` values taken into account.\r\n *\r\n * For instance, if we are attempting to remove part of an \"immutable\" entity\r\n * range, the entire entity must be removed. The returned `SelectionState`\r\n * will be adjusted accordingly.\r\n */\r\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\r\n  var start = selectionState.getStartOffset();\r\n  var end = selectionState.getEndOffset();\r\n  var startEntityKey = startBlock.getEntityAt(start);\r\n  var endEntityKey = endBlock.getEntityAt(end - 1);\r\n  if (!startEntityKey && !endEntityKey) {\r\n    return selectionState;\r\n  }\r\n  var newSelectionState = selectionState;\r\n  if (startEntityKey && startEntityKey === endEntityKey) {\r\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\r\n  } else if (startEntityKey && endEntityKey) {\r\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\r\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\r\n    newSelectionState = newSelectionState.merge({\r\n      anchorOffset: startSelectionState.getAnchorOffset(),\r\n      focusOffset: endSelectionState.getFocusOffset(),\r\n      isBackward: false\r\n    });\r\n  } else if (startEntityKey) {\r\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\r\n    newSelectionState = newSelectionState.merge({\r\n      anchorOffset: _startSelectionState.getStartOffset(),\r\n      isBackward: false\r\n    });\r\n  } else if (endEntityKey) {\r\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\r\n    newSelectionState = newSelectionState.merge({\r\n      focusOffset: _endSelectionState.getEndOffset(),\r\n      isBackward: false\r\n    });\r\n  }\r\n  return newSelectionState;\r\n}\r\n\r\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\r\n  var start = selectionState.getStartOffset();\r\n  var end = selectionState.getEndOffset();\r\n  var entity = entityMap.__get(entityKey);\r\n  var mutability = entity.getMutability();\r\n  var sideToConsider = isEntityAtStart ? start : end;\r\n\r\n  // `MUTABLE` entities can just have the specified range of text removed\r\n  // directly. No adjustments are needed.\r\n  if (mutability === 'MUTABLE') {\r\n    return selectionState;\r\n  }\r\n\r\n  // Find the entity range that overlaps with our removal range.\r\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\r\n    return sideToConsider <= range.end && sideToConsider >= range.start;\r\n  });\r\n\r\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\r\n\r\n  var entityRange = entityRanges[0];\r\n\r\n  // For `IMMUTABLE` entity types, we will remove the entire entity range.\r\n  if (mutability === 'IMMUTABLE') {\r\n    return selectionState.merge({\r\n      anchorOffset: entityRange.start,\r\n      focusOffset: entityRange.end,\r\n      isBackward: false\r\n    });\r\n  }\r\n\r\n  // For `SEGMENTED` entity types, determine the appropriate segment to\r\n  // remove.\r\n  if (!isEntireSelectionWithinEntity) {\r\n    if (isEntityAtStart) {\r\n      end = entityRange.end;\r\n    } else {\r\n      start = entityRange.start;\r\n    }\r\n  }\r\n\r\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\r\n\r\n  return selectionState.merge({\r\n    anchorOffset: removalRange.start,\r\n    focusOffset: removalRange.end,\r\n    isBackward: false\r\n  });\r\n}\r\n\r\nmodule.exports = getCharacterRemovalRange;"],"mappings":"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"},"metadata":{},"sourceType":"script"}